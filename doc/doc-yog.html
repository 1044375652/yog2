<h4 class=""><a name="Yog对象" class="anchor" href="#Yog对象"><span class="doc-link"></span></a>Yog对象</h4><p>Yog2暴露了一个名为 <code>yog</code> 的全局变量，方便一些系统功能的挂载和调用。</p>
<h5 class=""><a name="yog.dispatcher" class="anchor" href="#yog.dispatcher"><span class="doc-link"></span></a>yog.dispatcher</h5><p><code>yog.dispatcher</code> 是Yog2的自动路由处理器，通过 <code>yog.dispatcher</code> 可以方便的获取App路由与执行器</p>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">var</span> commonRouter = yog.disptahcer.router('common');
<span class="hljs-keyword">var</span> <span class="hljs-keyword">error</span> = commonRouter.action('<span class="hljs-keyword">error</span>');
<span class="hljs-keyword">error</span>= yog.dispatcher.action('common/<span class="hljs-keyword">error</span>');
</code></pre>
<p>它的应用场景有很多，最常用的有</p>
<h6 class=""><a name="设置router别名" class="anchor" href="#设置router别名"><span class="doc-link"></span></a>设置router别名</h6><p>Yog2默认是以App的<code>fis-conf.js</code>中namespace配置为router名称，如果希望自动路由可以使用其他名称访问App，那么就需要在rootRouter中设置路由的别名</p>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">router</span>.<span class="hljs-literal">use</span>(<span class="hljs-string">'/custom'</span>, yog.dispatcher.<span class="hljs-keyword">router</span>(<span class="hljs-string">'home'</span>))
// http://www.example.com/<span class="hljs-function">custom =&gt;</span> app/<span class="hljs-literal">home</span>/index/index.js
</code></pre>
<h6 class=""><a name="设置appRouter" class="anchor" href="#设置appRouter"><span class="doc-link"></span></a>设置appRouter</h6><p>Yog2的自动路由是根据URL查找同名文件，如果有一些特别的URL希望更强的定制能力，那么可以通过appRouter进行设置</p>
<blockquote>
<p>appRouter可以在 <code>server/router.js</code> 中修改。</p>
</blockquote>
<pre><code class="hljs lang-javascript"><span class="xml">module.exports = function(router)</span><span class="hljs-expression">{
    /<span class="hljs-end-block">/ request </span><span class="hljs-end-block">/spa</span><span class="hljs-end-block">/some</span><span class="hljs-end-block">/hefangshi </span>= <span class="hljs-end-block">/spa</span><span class="hljs-end-block">/api.js</span>
    <span class="hljs-variable">router.get</span>('<span class="hljs-end-block">/some</span>/:<span class="hljs-variable">user</span>', <span class="hljs-variable">yog.dispatcher.action</span>('<span class="hljs-variable">spa</span><span class="hljs-end-block">/api</span>'));
}</span><span class="xml">;</span>
</code></pre>
<h6 class=""><a name="Action调用" class="anchor" href="#Action调用"><span class="doc-link"></span></a>Action调用</h6><p>我们也可以在Action代码中直接调用其他Action进行页面请求处理，注意这里你甚至可以进行跨App的Action调用，但是这种能力的使用应该十分慎重，建议仅限定的其他App对Common App的调用。</p>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">// spa/action/some.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span></span>{
    yog.dispatcher.action(<span class="hljs-string">'spa/api'</span>)(req, res, next);
};
</code></pre>
<h5 class=""><a name="yog.require" class="anchor" href="#yog.require"><span class="doc-link"></span></a>yog.require</h5><p><code>yog.require</code> 提供了跨App的require能力。</p>
<p>对于跨App的调用，我们建议慎重使用，最好只限定在其他App对Common App的调用，Common App中可以存放一些通用的组件。</p>
<pre><code class="hljs lang-javascript"><span class="hljs-regexp">//</span> 通过yog.<span class="hljs-built_in">require</span> 可以跨App调用其余模块的后端脚本
<span class="hljs-reserved">var</span> util = yog.<span class="hljs-built_in">require</span>(<span class="hljs-string">'common/libs/util.js'</span>);
</code></pre>
<h5 class=""><a name="yog.log" class="anchor" href="#yog.log"><span class="doc-link"></span></a>yog.log</h5><p><code>yog.log</code> 提供了日志记录能力</p>
<pre><code class="hljs lang-javascript">yog.<span class="hljs-keyword">log</span>.fatal(<span class="hljs-string">'some fatal'</span>);
yog.<span class="hljs-keyword">log</span>.<span class="hljs-keyword">warning</span>(<span class="hljs-string">'some warning'</span>);
yog.<span class="hljs-keyword">log</span>.notice(<span class="hljs-string">'some notice'</span>);
yog.<span class="hljs-keyword">log</span>.<span class="hljs-keyword">trace</span>(<span class="hljs-string">'some trace'</span>);
yog.<span class="hljs-keyword">log</span>.debug(<span class="hljs-string">'some debug'</span>);
</code></pre>
<h5 class=""><a name="yog.ral" class="anchor" href="#yog.ral"><span class="doc-link"></span></a>yog.ral</h5><p><code>yog.ral</code> 提供了后端API请求能力</p>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">var</span> r = yog.ral(<span class="hljs-string">'SOME_SERVICE'</span>, <span class="hljs-comment">{
    data: {
        id: 1
    }</span>
});

r.<span class="hljs-keyword">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span><span class="hljs-comment">{
    console.log(data);
}</span>);</span>

r.<span class="hljs-keyword">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span><span class="hljs-comment">{
    console.log(err);
}</span>);</span>
</code></pre>
<p>Ral是一个后端资源统一请求层，最常见的场景是封装HTTP请求，它的特色在于实现了请求协议与数据打包协议的解耦，并且提供了负载均衡与超时、异常重试机制。更多的文档可以参考<a href="https://github.com/fex-team/node-ral">node-ral</a>，百度产品线用户可以参考<a href="http://git.baidu.com/fex/yog-ral/tree/master">yog-ral</a>。</p>
