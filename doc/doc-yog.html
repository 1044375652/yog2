<h4 class=""><a name="Yog%E5%AF%B9%E8%B1%A1" class="anchor" href="#Yog%E5%AF%B9%E8%B1%A1"><span class="octicon octicon-link"></span></a>Yog对象</h4><p>Yog2 暴露了一个名为 <code>yog</code> 的全局变量，方便一些系统功能的挂载和调用。</p>
<h5 class=""><a name="yog.dispatcher" class="anchor" href="#yog.dispatcher"><span class="octicon octicon-link"></span></a>yog.dispatcher</h5><p><code>yog.dispatcher</code> 是 Yog2 的自动路由处理器，通过 <code>yog.dispatcher</code> 可以方便的获取 App 路由与执行器</p>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">var</span> commonRouter = yog.disptahcer.router('common');
<span class="hljs-keyword">var</span> <span class="hljs-keyword">error</span> = commonRouter.action('<span class="hljs-keyword">error</span>');
<span class="hljs-keyword">error</span>= yog.dispatcher.action('common/<span class="hljs-keyword">error</span>');
</code></pre>
<p>它的应用场景有很多，最常用的有</p>
<h6 class=""><a name="%E8%AE%BE%E7%BD%AErouter%E5%88%AB%E5%90%8D" class="anchor" href="#%E8%AE%BE%E7%BD%AErouter%E5%88%AB%E5%90%8D"><span class="octicon octicon-link"></span></a>设置router别名</h6><p>Yog2 默认是以 App 的 <code>fis-conf.js</code> 中 namespace 配置为 router 名称，如果希望自动路由可以使用其他名称访问 App，那么就需要在 rootRouter 中设置路由的别名</p>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">router</span>.<span class="hljs-literal">use</span>(<span class="hljs-string">'/custom'</span>, yog.dispatcher.<span class="hljs-keyword">router</span>(<span class="hljs-string">'home'</span>))
// http://www.example.com/<span class="hljs-function">custom =&gt;</span> app/<span class="hljs-literal">home</span>/index/index.js
</code></pre>
<h6 class=""><a name="%E8%AE%BE%E7%BD%AEappRouter" class="anchor" href="#%E8%AE%BE%E7%BD%AEappRouter"><span class="octicon octicon-link"></span></a>设置appRouter</h6><p>Yog2 的自动路由是根据 URL 查找同名文件，如果有一些特别的 URL 希望更强的定制能力，那么可以通过 appRouter 进行设置</p>
<blockquote>
<p>appRouter 可以在 <code>server/router.js</code> 中修改。</p>
</blockquote>
<pre><code class="hljs lang-javascript"><span class="xml">module.exports = function(router)</span><span class="hljs-expression">{
    /<span class="hljs-end-block">/ request </span><span class="hljs-end-block">/spa</span><span class="hljs-end-block">/some</span><span class="hljs-end-block">/hefangshi </span>= <span class="hljs-end-block">/spa</span><span class="hljs-end-block">/api.js</span>
    <span class="hljs-variable">router.get</span>('<span class="hljs-end-block">/some</span>/:<span class="hljs-variable">user</span>', <span class="hljs-variable">yog.dispatcher.action</span>('<span class="hljs-variable">spa</span><span class="hljs-end-block">/api</span>'));
}</span><span class="xml">;</span>
</code></pre>
<h6 class=""><a name="Action%E8%B0%83%E7%94%A8" class="anchor" href="#Action%E8%B0%83%E7%94%A8"><span class="octicon octicon-link"></span></a>Action调用</h6><p>我们也可以在 Action 代码中直接调用其他 Action 进行页面请求处理，注意这里你甚至可以进行跨 App 的 Action 调用，但是这种能力的使用应该十分慎重，建议仅限定的其他 App 对 Common App 的调用。</p>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">// spa/action/some.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span></span>{
    yog.dispatcher.action(<span class="hljs-string">'spa/api'</span>)(req, res, next);
};
</code></pre>
<h5 class=""><a name="yog.require" class="anchor" href="#yog.require"><span class="octicon octicon-link"></span></a>yog.require</h5><p><code>yog.require</code> 提供了跨 App 的 require 能力。</p>
<p>对于跨 App 的调用，我们建议慎重使用，最好只限定在其他 App 对 Common App 的调用，Common App 中可以存放一些通用的组件。</p>
<pre><code class="hljs lang-javascript"><span class="hljs-regexp">//</span> 通过yog.<span class="hljs-built_in">require</span> 可以跨App调用其余模块的后端脚本
<span class="hljs-reserved">var</span> util = yog.<span class="hljs-built_in">require</span>(<span class="hljs-string">'common/libs/util.js'</span>);
</code></pre>
<h5 class=""><a name="yog.log" class="anchor" href="#yog.log"><span class="octicon octicon-link"></span></a>yog.log</h5><p><code>yog.log</code> 提供了日志记录能力</p>
<pre><code class="hljs lang-javascript">yog.<span class="hljs-keyword">log</span>.fatal(<span class="hljs-string">'some fatal'</span>);
yog.<span class="hljs-keyword">log</span>.<span class="hljs-keyword">warning</span>(<span class="hljs-string">'some warning'</span>);
yog.<span class="hljs-keyword">log</span>.notice(<span class="hljs-string">'some notice'</span>);
yog.<span class="hljs-keyword">log</span>.<span class="hljs-keyword">trace</span>(<span class="hljs-string">'some trace'</span>);
yog.<span class="hljs-keyword">log</span>.debug(<span class="hljs-string">'some debug'</span>);
</code></pre>
<h5 class=""><a name="yog.ral" class="anchor" href="#yog.ral"><span class="octicon octicon-link"></span></a>yog.ral</h5><p><code>yog.ral</code> 提供了后端 API 请求能力</p>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">var</span> r = yog.ral(<span class="hljs-string">'SOME_SERVICE'</span>, <span class="hljs-comment">{
    data: {
        id: 1
    }</span>
});

r.<span class="hljs-keyword">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span><span class="hljs-comment">{
    console.log(data);
}</span>);</span>

r.<span class="hljs-keyword">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span><span class="hljs-comment">{
    console.log(err);
}</span>);</span>
</code></pre>
<p>Ral 是一个后端资源统一请求层，最常见的场景是封装 HTTP 请求，它的特色在于实现了请求协议与数据打包协议的解耦，并且提供了负载均衡与超时、异常重试机制。更多的文档可以参考 <a href="https://github.com/fex-team/node-ral">node-ral</a>，百度产品线用户可以参考 <a href="http://git.baidu.com/fex/yog-ral/tree/master">yog-ral</a>。</p>
