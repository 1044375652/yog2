<h3 class="" id="控制器"><a name="%E6%8E%A7%E5%88%B6%E5%99%A8" href="#%E6%8E%A7%E5%88%B6%E5%99%A8">控制器</a></h3><p>控制器是 Web 服务实际业务逻辑的载体，路由系统会将请求根据路由规则分发到控制器，由控制器去解析请求参数、访问数据服务以及返回结果。在 yog2 中，控制器就是路由系统指向的 <code>action</code> 文件。</p>
<p>以一个简单的用户创建与获取的 API 为例简单说明一下用法</p>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">var</span> userModel = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../models/userModel.js'</span>);

<span class="hljs-built_in">module</span>.exports.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res, next)</span> </span>{
    <span class="hljs-keyword">var</span> id = <span class="hljs-built_in">parseInt</span>(req.body.id, <span class="hljs-number">10</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(id)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'invalid id'</span>);
    }
    userModel.get(id)
    .then(res.json.bind(<span class="hljs-keyword">this</span>))
    .catch(next);
}

<span class="hljs-built_in">module</span>.exports.post = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res, next)</span> </span>{
    <span class="hljs-keyword">var</span> name = req.body.name;
    <span class="hljs-keyword">var</span> gender = req.body.gender ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (!name) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'invalid name'</span>);
    }
    userModel.save({
        name: name,
        gender: gender
    })
    .then(res.json.bind(<span class="hljs-keyword">this</span>))
    .catch(next);
}
</code></pre>
<p>可以看出控制器中的函数实际上就是 express 在路由注册时的回调函数，因此其中的参数 <code>req</code> <code>res</code> <code>next</code> 均可以参考  <a href="http://expressjs.com/4x/api.html">express 文档 </a> 使用。</p>
<h3 class="" id="数据模型"><a name="%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">数据模型</a></h3><p>由于 yog2 的核心目标是更好的提供 UI 中间层 支持，因此并未内置任何数据库 ORM 功能。当然，通过中间件和插件扩展，我们也可以很轻松的引入类似 <a href="https://github.com/balderdashy/waterline">waterline</a> 和 <a href="https://github.com/Automattic/mongoose">mongoose</a> 这类 ORM 库用于数据库的访问。</p>
<p>虽然没有内置 ORM 功能，但是我们提供了一套后端服务管理工具用于 UI 中间层对后端服务层的请求管理。</p>
<p>数据模型又可以分为服务层和数据层，服务层可以专注与业务逻辑封装和数据层的调用，数据层则专注于与后端服务层的交互。当然在业务不复杂的时候，我们也可以直接将服务层与数据层融合。</p>
<p>以控制器中的 userModel 为例，我们可以实现一个简单的数据模型。</p>
<pre><code class="hljs lang-javascript">// /server/models/userModel.js

<span class="hljs-keyword">var</span> yog = require('yog2-kernel');

module.exports.get = function (id) {
    <span class="hljs-keyword">return</span> yog.ral('<span class="hljs-type">BACKEND</span>', {
        path: '/api/user',
        <span class="hljs-keyword">method</span>: '<span class="hljs-type">GET</span>',
        data: {
            id: id
        }
    });
};

module.exports.save = function (user) {
    <span class="hljs-keyword">return</span> yog.ral('<span class="hljs-type">BACKEND</span>', {
        path: '/api/user',
        <span class="hljs-keyword">method</span>: '<span class="hljs-type">POST</span>',
        pack: 'form',
        data: user
    });
};
</code></pre>
<p>其中 <code>yog.ral</code> 是 yog2 框架的后端服务管理工具，使用之前需要在 project 中进行一些简单的配置。</p>
<pre><code class="hljs lang-javascript">// /conf/ral/backend.js
module.exports = {
    <span class="hljs-type">BACKEND</span>: {
        protocol: 'http',
        pack: 'querystring',
        unpack: 'json',
        <span class="hljs-keyword">method</span>: '<span class="hljs-type">GET</span>',
        balance: 'roundrobin',
        server: [
            {
                host: 'backend.server', 
                port: <span class="hljs-number">80</span>
            }
        ]
    }
}
</code></pre>
<blockquote>
<p>要如示例中 Promise 的形式使用 yog.ral ，需要安装插件 <a href="https://github.com/hefangshi/yog2-plugin-ral-promise">yog2-plugin-ral-promise</a></p>
</blockquote>
<h3 class="" id="模板引擎"><a name="%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E" href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E">模板引擎</a></h3><p>yog2 默认使用了 <a href="https://github.com/paularmstrong/swig">swig</a> 作为模板引擎。同时我们扩展了模版引擎使其能够支持更多的功能，其中最核心的功能就是 FIS 的后端静态资源管理能力，这个功能将会在 <a href="#%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96"> 前端工程化 </a> 一节详细描述，在此我们会介绍一下如何在 yog2 中使用模板引擎。</p>
<p>在 yog2 中，我们一般会将模板根据使用类别的不同，分别将页面类型的后端模板放至于 app 的 <code>/client/page</code> 目录中，而将组件类型的后端模板放至于 app 的  <code>/client/widget/WIDGET_NAME</code> 目录中。</p>
<p>以 <code>yog2 init app</code> 生成的默认 DEMO 为例</p>
<pre><code>├── client
│   ├── page
│   │   ├── index<span class="hljs-class">.tpl</span>
│   │   └── layout<span class="hljs-class">.tpl</span>
│   └── widget
│       └── message
│           └── message<span class="hljs-class">.tpl</span>
├── fis-conf.js
</code></pre><p>我们可以看到其中拥有三个 <code>tpl</code> ，即后端模板文件，其中 <code>layout.tpl</code> 是页面的母版页，其中可以实现一些页面间共用的部分，而 <code>index.tpl</code> 则是我们首页的后端模板。<code>message.tpl</code> 则是供各个页面引用的后端模板组件。</p>
<p>当拥有了模板后，我们还有一个工作就是将数据传递给模板，并将渲染结果返回前端。这类操作如前文所说，应该在控制器也就是 action 中完成。还是以前文中的 userModel 为例，我们将用户信息不以 JSON 的形式，而是以页面的形式展现出来。</p>
<pre><code><span class="hljs-keyword">var</span> userModel = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../models/userModel.js'</span>);

<span class="hljs-built_in">module</span>.exports.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res, next)</span> </span>{
    <span class="hljs-keyword">var</span> id = <span class="hljs-built_in">parseInt</span>(req.body.id, <span class="hljs-number">10</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(id)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'invalid id'</span>);
    }
    userModel.get(id)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(user)</span> </span>{
        res.render(<span class="hljs-string">'home/page/index.tpl'</span>, {
            user: user
        });
    })
    .catch(next);
}
</code></pre><p>通过 <code>res.render</code> 函数，我们就可以将数据注入至模板进行渲染并返回了。值得注意的是，在模板路径的书写上，我们需要按照 <code>APP_NAME/page/PAGE.tpl</code> 的格式书写。</p>
