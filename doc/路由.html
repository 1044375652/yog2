<p>yog2 框架在 express 的路由基础上，提供了自动路由与多级路由系统。目的是让 UI 层开发更高效、更规范的同时又能够保证最大的灵活性。</p>
<p>yog2 的路由分为两类。一类是根路由，其角色与传统的 Express 路由非常类似，是所有请求的一致入口，因此我们在根路由拥有最大的自由度，可以做任何转发。另一类是 app 路由，它只能接收根路由分发到各个 app 的请求，请求在 app 中如何分发则可以完全由 app 路由控制。</p>
<h4 class=""><a name="%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1" href="#%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1">自动路由</a></h4><p>基于 <code> 约定优于配置 </code> 的思想，我们提供了自动路由功能，目的是让开发者无需像 express 中一样手动注册路由，只需要在指定的目录按照指定的规则创建文件就可以创建一个 Web 服务。</p>
<h5 class=""><a name="%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99" href="#%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99">路由规则</a></h5><p>自动路由用于管理 url 与 action 之间的映射关系，默认的路由规则为</p>
<pre><code class="hljs lang-text">http://www.example.com/<span class="hljs-literal">home</span>/<span class="hljs-function">index =&gt;</span> app/<span class="hljs-literal">home</span>/action/index.js

http://www.example.com/<span class="hljs-literal">home</span>/doc/<span class="hljs-function">detail =&gt;</span> app/<span class="hljs-literal">home</span>/action/doc/detail.js
</code></pre>
<p>如果上述规则没有匹配成功，会尝试匹配同名文件夹下的 index.js，即</p>
<pre><code class="hljs lang-text">http://www.example.com/<span class="hljs-literal">home</span>/<span class="hljs-function">index =&gt;</span> app/<span class="hljs-literal">home</span>/action/index/index.js

http://www.example.com/<span class="hljs-literal">home</span>/doc/<span class="hljs-function">detail =&gt;</span> app/<span class="hljs-literal">home</span>/action/doc/detail/index.js
</code></pre>
<p>从上述规则我们可以看出，自动路由会将网站第一级目录识别为 app 的名称，会根据这个名称寻找同名的 app 进行转发。而在 app 路由的处理过程中，会根据 action 文件夹下的目录结构进行进一步的转发。</p>
<p>通过上述自动路由规则，我们可以不编写任何路由代码，就组织出一个拥有多级目录的站点。</p>
<h5 class=""><a name="method%20%E8%BD%AC%E5%8F%91" href="#method%20%E8%BD%AC%E5%8F%91">method 转发</a></h5><p>同一个 <code>action</code> 文件一般只会对应一个 URL ，但是 yog2 提供了按照 <code>HTTP METHOD</code> 进行自动转发的能力，举例来说</p>
<pre><code><span class="hljs-comment">//app/home/action/index.js</span>

<span class="hljs-comment">// GET /home/index</span>
module.<span class="hljs-keyword">exports</span>.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res)</span> <span class="hljs-comment">{}</span>;</span>

<span class="hljs-comment">// POST /home/index</span>
module.<span class="hljs-keyword">exports</span>.post = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res)</span> <span class="hljs-comment">{}</span>;</span>

<span class="hljs-comment">// PUT /home/index</span>
module.<span class="hljs-keyword">exports</span>.put = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res)</span> <span class="hljs-comment">{}</span>;</span>

<span class="hljs-comment">// DELETE /home/index</span>
module.<span class="hljs-keyword">exports</span>.delete = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res)</span> <span class="hljs-comment">{}</span>;</span>
</code></pre><blockquote>
<p><code>METHOD</code> 名称均为小写</p>
</blockquote>
<p>通过 <code>METHOD</code> 转发功能，我们可以为同一个 URL ，分别定义在不同 <code>METHOD</code> 请求下的行为。</p>
<p>此外，如果同时存在 <code>module.exports</code> 函数与 <code>module.exports.$METHOD</code> 函数，如</p>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">//app/home/action/index.js</span>

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res, next)</span> </span>{
    req.user = req.session.user;
    next();
}

<span class="hljs-comment">// GET /home/index</span>
<span class="hljs-built_in">module</span>.exports.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res)</span> </span>{};

<span class="hljs-comment">// POST /home/index</span>
<span class="hljs-built_in">module</span>.exports.post = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(req, res)</span> </span>{};
</code></pre>
<p>此时无论是 <code>GET</code> 请求还是 <code>POST</code> 请求，都会先经过 <code>module.exports</code> 函数处理后再进入各自的 <code>METHOD</code> 函数，因此我们可以将 <code>module.exports</code> 函数视为 URL 级别的通用处理逻辑。</p>
<h5 class=""><a name="%E8%B7%AF%E7%94%B1%E6%89%A9%E5%B1%95" href="#%E8%B7%AF%E7%94%B1%E6%89%A9%E5%B1%95">路由扩展</a></h5><p>除了自动路由外，总会存在一些 URL 设计是自动路由无法满足的，因此 yog2 框架也提供了极为灵活的路由扩展能力，你甚至可以通过路由扩展能力完全的屏蔽自动路由的功能。</p>
<h5 class=""><a name="root%20%E8%B7%AF%E7%94%B1%E6%89%A9%E5%B1%95" href="#root%20%E8%B7%AF%E7%94%B1%E6%89%A9%E5%B1%95">root 路由扩展</a></h5><p>根路由 rootRouter 是用于管理 yog2 项目的根路由，通过扩展根路由，我们可以完全的控制请求入口。</p>
<blockquote>
<p>rootRouter 可以在 project 目录中的 <code>conf/plugins/dispatcher.js</code> 中修改</p>
<p>router 更多的使用方法可以参考 <a href="http://expressjs.com/4x/api.html#router">Express 文档 </a></p>
</blockquote>
<p>可以为一个 app 设置一个别名</p>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">router</span>.<span class="hljs-literal">use</span>(<span class="hljs-string">'/custom'</span>, yog.dispatcher.<span class="hljs-keyword">router</span>(<span class="hljs-string">'home'</span>))
// http://www.example.com/<span class="hljs-function">custom =&gt;</span> app/<span class="hljs-literal">home</span>/index/index.js
</code></pre>
<p>可以直接建立一个特殊的 URL</p>
<pre><code class="hljs lang-javascript">router.<span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-string">'/somespecial'</span>, yog.dispatcher.action(<span class="hljs-string">'home/doc/detail'</span>)</span></span>)
<span class="hljs-comment">// http://www.example.com/somespecial =&gt; app/home/doc/detail.js</span>
</code></pre>
<p>也可以在此处将 router 当成 app 使用，加载任意中间件</p>
<pre><code class="hljs lang-javascript">router.<span class="hljs-keyword">use</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span></span>{
});
</code></pre>
<h5 class=""><a name="app%20%E8%B7%AF%E7%94%B1%E6%89%A9%E5%B1%95" href="#app%20%E8%B7%AF%E7%94%B1%E6%89%A9%E5%B1%95">app 路由扩展</a></h5><p>appRouter 用于管理进入 app 后的请求分发，在这里你可以加载 app 级别的中间件或者通用逻辑，也可以用于实现自动路由无法满足的 URL 设计需求。</p>
<blockquote>
<p>appRouter 可以在 app 目录中的 <code>server/router.js</code> 中修改。</p>
<p>router 更多的使用方法可以参考 <a href="http://expressjs.com/4x/api.html#router">Express 文档 </a></p>
</blockquote>
<pre><code class="hljs lang-javascript">module.exports = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(router)</span></span>{
    <span class="hljs-comment">// you can add app common logic here</span>
    router.<span class="hljs-keyword">use</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span></span>{
    });

    <span class="hljs-comment">// also you can add custom action</span>
    <span class="hljs-comment">// request /spa/some/hefangshi</span>
    router.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/some/:user'</span>, router.action(<span class="hljs-string">'api'</span>));

    <span class="hljs-comment">// or write action directly</span>
    router.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/some/:user'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res, req)</span></span>{});

    <span class="hljs-comment">// a restful api example</span>
    router.route(<span class="hljs-string">'/book'</span>)
        <span class="hljs-comment">// PUT /cdcd/book/id</span>
        .put(router.action(<span class="hljs-string">'book'</span>).put)
        <span class="hljs-comment">// GET /cdcd/book</span>
        .<span class="hljs-keyword">get</span>(router.action(<span class="hljs-string">'book'</span>));

    router.route(<span class="hljs-string">'/book/id/:id'</span>)
        <span class="hljs-comment">// GET /cdcd/book/id</span>
        .<span class="hljs-keyword">get</span>(router.action(<span class="hljs-string">'book'</span>).<span class="hljs-keyword">get</span>)
        <span class="hljs-comment">// DELETE /cdcd/book/id</span>
        .<span class="hljs-keyword">delete</span>(router.action(<span class="hljs-string">'book'</span>).<span class="hljs-keyword">delete</span>);
};
</code></pre>
