<p>yog2 是基于 <a href="http://fis.baidu.com">fis</a> 构建的 Node.js UI 中间层解决方案，因此整个框架都深度契合 fis 的前端工程化概念。在 yog2 中你可以享受到完整的 <a href="http://fis.baidu.com">fis</a> 解决方案的前端优势。</p>
<h4 class=""><a name="%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83" href="#%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83">目录规范</a></h4><p>在 yog2 中我们提供了一套固定的目录规范方便开发者快速开发，在了解了 fis 的配置原理后，也可以方便的调整这套目录规范。</p>
<pre><code class="hljs lang-bash">├─<span class="hljs-keyword">client</span>                 <span class="hljs-preprocessor"># 前端代码</span>
│  ├─page                <span class="hljs-preprocessor"># 前端页面</span>
│  ├─<span class="hljs-keyword">static</span>              <span class="hljs-preprocessor"># 前端非模块化静态资源</span>
│  │  ├─css
│  │  └─js
│  └─widget              <span class="hljs-preprocessor"># 前端组件</span>
├─fis-conf.js            <span class="hljs-preprocessor"># FIS编译配置</span>
</code></pre>
<p>app 下的 client 目录就是前端代码的开发目录，所有的前端资源均在这里存放。其中有两个特殊的目录 <code>page</code> 和 <code>widget</code>。 <code>page</code> 中存放的是前端页面的后端模板，<code>widget</code> 中存放的是后端组件，后端组件可以调用其他组件，也可以被页面调用，通过将站点划分为一个个组件，我们可以更好的去管理和复用组件代码。</p>
<p>除此之外，<code>widget</code> 目录下的 JavaScript 脚本均需要遵守 <strong>CommonJS</strong> 规范，与 Node.js 模块化的编写标准一致，使用 <code>require</code> 获取模块，使用 <code>module</code> 和 <code>exports</code> 暴露接口。</p>
<p>并不推荐在 yog2 中使用 AMD 规范的模块化加载类库。</p>
<h4 class=""><a name="%E4%B8%89%E7%A7%8D%E8%AF%AD%E8%A8%80%E8%83%BD%E5%8A%9B" href="#%E4%B8%89%E7%A7%8D%E8%AF%AD%E8%A8%80%E8%83%BD%E5%8A%9B">三种语言能力</a></h4><h5 class=""><a name="%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D" href="#%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D">资源定位</a></h5><p>资源定位能力，可以有效的分离开发路径与部署路径之间的关系，工程师不再关心资源部署到线上之后去了哪里，变成了什么名字，这些都可以通过配置来指定。而工程师只需要使用相对路径来定位自己的开发资源即可。这样的好处是 <strong>资源可以发布到任何静态资源服务器的任何路径上而不用担心线上运行时找不到它们 </strong>，而且代码 <strong> 具有很强的可移植性</strong>，甚至可以从一个产品线移植到另一个产品线而不用担心线上部署不一致的问题。</p>
<ul>
<li><a href="#%E5%9C%A8html%E4%B8%AD%E5%AE%9A%E4%BD%8D%E8%B5%84%E6%BA%90">在 html 中定位资源</a></li>
<li><a href="#%E5%9C%A8js%E4%B8%AD%E5%AE%9A%E4%BD%8D%E8%B5%84%E6%BA%90">在 js 中定位资源</a></li>
<li><a href="#%E5%9C%A8css%E4%B8%AD%E5%AE%9A%E4%BD%8D%E8%B5%84%E6%BA%90">在 css 中定位资源</a></li>
</ul>
<h5 class=""><a name="%E5%86%85%E5%AE%B9%E5%B5%8C%E5%85%A5" href="#%E5%86%85%E5%AE%B9%E5%B5%8C%E5%85%A5">内容嵌入</a></h5><p>内容嵌入可以为工程师提供诸如图片 base64 嵌入到 css、js 里，前端模板编译到 js 文件中，将 js、css、html 拆分成几个文件最后合并到一起的能力。有了这项能力，可以有效的减少 http 请求数，提升工程的可维护性。 <em>fis 不建议用户使用内容嵌入能力作为组件化拆分的手段 </em>，因为依赖声明能力会更适合组件化开发。</p>
<ul>
<li><a href="#%E5%9C%A8html%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%B5%84%E6%BA%90">在 html 中嵌入资源</a></li>
<li><a href="#%E5%9C%A8js%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%B5%84%E6%BA%90">在 js 中嵌入资源</a></li>
<li><a href="#%E5%9C%A8css%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%B5%84%E6%BA%90">在 css 中嵌入资源</a></li>
</ul>
<h5 class=""><a name="%E4%BE%9D%E8%B5%96%E5%A3%B0%E6%98%8E" href="#%E4%BE%9D%E8%B5%96%E5%A3%B0%E6%98%8E">依赖声明</a></h5><blockquote>
<p>依赖声明能力为工程师提供了声明依赖关系的编译接口。fis 在执行编译的过程中，会扫描这些编译标记，从而建立一张 <strong>静态资源关系表 </strong>，它在编译阶段最后会被产出为一份 <strong>map.json</strong> 文件，这份文件详细记录了项目内的静态资源 id、发布后的线上路径、资源类型以及 <strong> 依赖关系 </strong> 和 <strong> 资源打包 </strong> 等信息。使用 fis 作为编译工具的项目，可以将这张表提交给后端或者前端框架去运行时根据组件使用情况来 <strong>按需加载资源或者资源所在的包</strong>，从而提升前端页面运行性能。</p>
</blockquote>
<ul>
<li><a href="#%E5%9C%A8html%E4%B8%AD%E5%A3%B0%E6%98%8E%E4%BE%9D%E8%B5%96">在 html 中声明依赖</a></li>
<li><a href="#%E5%9C%A8js%E4%B8%AD%E5%A3%B0%E6%98%8E%E4%BE%9D%E8%B5%96">在 js 中声明依赖</a></li>
<li><a href="#%E5%9C%A8css%E4%B8%AD%E5%A3%B0%E6%98%8E%E4%BE%9D%E8%B5%96">在 css 中声明依赖</a></li>
</ul>
<h4 class=""><a name="%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96">前端模块化</a></h4><p>在 yog2 中，我们可以轻松的使用模块化的能力管理前端业务代码。所有放在 widget 目录下的 JavaScript 脚本都需要符合 CommonJS 规范，即像编写 Node.js 代码一样编写前端代码。</p>
<p>比如我们可以声明一个模块 word</p>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">// /client/widget/word/word.js</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">export</span> = <span class="hljs-string">'A'</span>;
</code></pre>
<p>我们可以在其他脚本中引用 word 模块</p>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">// /client/widget/index.js</span>
<span class="hljs-keyword">var</span> word = <span class="hljs-built_in">require</span>(<span class="hljs-string">'home:widget/word/word.js'</span>);
alert(word);

<span class="hljs-comment">// A</span>
</code></pre>
<p>也可以在页面中引用 word 模块</p>
<pre><code class="hljs lang-html">/<span class="hljs-regexp">/ /client</span><span class="hljs-regexp">/page/index</span>.tpl

{% script %}
var word = <span class="hljs-keyword">require</span>(<span class="hljs-string">'home:widget/word/word.js);
alert(word);
{% endscript %}</span>
</code></pre>
